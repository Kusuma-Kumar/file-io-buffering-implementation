Saving intermediate results like this is called buffering and, not at all coincidentally, an arbitrary chunk of memory used for storing stuff is often called a buffer. This is directly related to the dreaded "Bufferingâ€¦" message one sees from Netflix: your computer has a chunk of memory (a buffer) in which it stores the next few seconds of video. Your computer is simultaneously reading from that buffer to display the video and also receiving new data from Netflix into the buffer. Your video stops playing when the buffer is empty; the message indicates that Netflix has to send more data to catch up with the rate at which the buffer is emptied.

For this assignment, you will produce a collection of functions that insulate a program from the inefficiencies of I/O-related system calls using the method discussed in class. You will create functions analogous to the system calls open(2), close(2), read(2), write(2), and lseek(2). You will also implement a function to flush a buffer: that is, to force all buffered data to be delivered to its destination (note that this only makes sense in the context of writing).

As implied above, the question of what constitutes "enough" is important. Traditionally, there are three options: unbuffered, in which data is immediately delievered to/from a process to the corresponding system call; line-buffered, in which the abstraction layer buffers a single line (ie, a string that ends in a newline character); and block buffered, in which the buffer is a fixed size (a "block"). For this assignment, you will implement a block-buffering scheme, whose block size is configurable at compile time.

In addition to the system calls enumerated above, you will likely find these library functions useful in your implementation: