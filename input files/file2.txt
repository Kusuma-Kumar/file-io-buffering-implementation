You will produce a source file, myls.c, that implements the required logic. When compiled and run with no arguments, it should list all non-hidden files in the current directory. When supplied with a list of arguments, it should behave as ls does: for all non-directories, list the files themselves; for all directories, list the contents; error if a file doesn’t exist. Ordering of the output is at your discretion (you will notice that, in a listing with both files and directories, ls will show all files first and then all directories, regardless of the order they appeared on the command-line; you do not need to do this). Unless a single filename exceeds 80 characters, the output of your program should not exceed 80 columns.

Furthermore, your ls program must accept the -a and -l options. When provided with the -a option, your program should list all files in the directories given, including hidden files. When provided with the -l option, your program should provide detailed information about each file, one file per line, just as the standard ls program does.

When provided with the -l option, your implementation does not need to print the "total ##" line that the standard version of ls prints.

You must use getopt(3) to parse command-line arguments.

You do not need to match the spacing of the real ls.

You may assume that a path will never exceed PATH_MAX bytes in length, even though this isn’t really true.

Deliverable requirements
myls.c, which should contain your implementation of ls.

Makefile, whose default target should build myls (out of myls.c), It may have as many other targets as you like, to make your life easier), but the default one must build that program. It must also have a clean target that removes all built files.

README, which will include a list of authors, a list of known bugs, and a list of resources you consulted in your work (a list of URLs is totally acceptable—if I can see the kinds of references you’re using, I can get a better idea of how to tailor the instruction to your needs—just keep the README file open as you work and paste them there when you find something useful).

Style requirements
Your code must exhibit:

appropriate use of comments;
appropriate use of stack, heap, global, and static variables;
appropriate use of constants;
efficient memory usage;
no magic numbers;
appropriate decomposition (a good rule of thumb is functions should be no more than 1 screen long);
clear organization (eg, grouped header files, struct definitions, function prototypes);
well-named variables, functions, and other identifiers;
verification of command-line arguments, if applicable;
checking and appropriate handling of all return values;
consistent style (capitalization, indenting, etc).